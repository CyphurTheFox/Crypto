/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Cyphur
 */

package com.cyphur.Crypto;


import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.GCMParameterSpec;
import java.nio.ByteBuffer;

public class AESToolKit {
    private byte[] keyBytes;
    private SecretKey Key;
    private SecureRandom generator;
    
    /**
     * Initializes the ToolKit when created to have
     * no key set, and creates a new SecureRandom
     * for the tool to use.
    */
    public AESToolKit(){
        generator = new SecureRandom();
    }
    
    /**
     * Generates a "Handshake" string that can be sent to another instance of AESToolKit to share the key between the two
     * instances. This string is not secured in any way, and thus requires
         * external encryption, such as the functionality provided in com.Cyphur.Crypto.RSAToolkit2.
     * 
     * @param securityFactor 
     * A number between 0 and 2 representing the desired security level, as indicated:
     * 0: 128 bit |    
     * 1: 192 bit |    
     * 2: 256 bit. 
     * If a key has already been generated, this value will be ignored
     * 
     * @return 
     * A string that when passed into the ParseHandshake function of another instance
     * of AESToolKit, will copy the key allowing them to encrypt/decrypt messages sent
     * between the two instances.
     */
    public String generateHandshake(int securityFactor) { /* takes 0, 1, or 2 to indicate a 128, 192, or 256 bit key length */
        if(securityFactor > 2 || securityFactor < 0){
            throw new IllegalArgumentException("Not a valid Security Level");
        }
        
        if (!keyGenerated()){
            generateKey(64*(2+securityFactor));
        }
        String handshake = "";
        handshake = handshake + String.valueOf(64*(securityFactor+2));
        String inter;
        for(byte b: keyBytes){
            inter = String.valueOf((int) Math.abs(b));
            while(inter.length() < 3){
                inter = "0" + inter;
            }
            if(((int) b) < 0){
                inter = "-" + inter;
            } else {
                inter = "0" + inter;
            }
            
            handshake = handshake+inter;
        }
        
        
        return handshake;
    }
    /**
     * Generates a "Handshake" string that can be sent to another instance of AESToolKit to share the key between the two
     * instances. This string is not secured in any way, and thus requires
     * external encryption, such as the functionality provided in com.Cyphur.Crypto.RSAToolkit.
     * 
     * @return 
     * A string that when passed into the ParseHandshake function of another instance
     * of AESToolKit, will copy the key allowing them to encrypt/decrypt messages sent
     * between the two instances.
     */
    
    public String generateHandshake(){
        return generateHandshake(2);
    }
    /**
     * A function that when passed the String generated by the generateHandshake
     * function of another instance of AESToolKit, will copy the key stored 
     * inside the handshake into this instance, allowing the two Instances to
     * Encrypt/Decrypt messages for each other.
     * 
     * @param Handshake 
     * A handshake sourced from the generateHandshake method of another instance
     * of AESToolKit
     */
    public void parseHandshake(String Handshake){
        String buf = "";
        for (int i = 0; i < 3; ++i){
            buf += Character.toString(Handshake.charAt(i));
        }
        int bigLen = Integer.parseInt(buf);
        if(bigLen == 128 || bigLen == 192 || bigLen == 256) {
            keyBytes = new byte[bigLen/8];
        } else {
            throw new IllegalArgumentException("Handshake Invalid!, Either this is not an acutal handshake, or something went wrong in transmission. Pleas let the sender know and try again!");
        }
        
        buf = "";
        int j = bigLen/8;
        for(int i = Handshake.length()-1; j >= 0 && i >= 0; --i){
            buf = Character.toString(Handshake.charAt(i)) + buf;
            if(buf.length() >= 4){
                --j;
                keyBytes[j] = (byte) Integer.parseInt(buf);
                buf = "";
            }
        }
        Key = new SecretKeySpec(keyBytes, "AES");
    }
    
    /**
     * generates an AES key of the specified bit length using SecureRandom.
     * 
     * @param bitLength 
     * The desired length of the key, in bits. Must be 128, 192, or 256.
     */
    public void generateKey(int bitLength){
        if(bitLength % 64 != 0){
            throw new IllegalArgumentException("Not a valid Bitlength");
        }
        keyBytes = new byte[bitLength/8];
        
        generator.nextBytes(keyBytes);
        Key = new SecretKeySpec(keyBytes, "AES");
        
    }
    
    /**
     * Encrypts the provided data into a byte array. Must be provided to an 
     * instance of AESToolKit with a matching key, otherwise the decryption will
     * fail.
     * 
     * @param data
     * data to be encrypted
     * 
     * @return
     * encrypted data
     */
    public byte[] encryptData(byte[] data){
        byte[] iv = new byte[12];
        byte[] message = {};
        generator.nextBytes(iv);
        
        try {
            final Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            GCMParameterSpec Spec = new GCMParameterSpec(128, iv);
            cipher.init(Cipher.ENCRYPT_MODE, Key, Spec);
        
            byte[] enc = cipher.doFinal(data);
        
            ByteBuffer buf = ByteBuffer.allocate(4+iv.length + enc.length);
            buf.putInt(iv.length);
            buf.put(iv);
            buf.put(enc);
        
            message = buf.array();
        
        }catch (NoSuchAlgorithmException | NoSuchPaddingException |InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException ex){
            Logger.getLogger(AESToolKit.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
        return message;
    }
    
    /**
     * decrypts a byte[] from another instance of AESToolKit. Only works if both
     * instances are sharing the same key. 
     * 
     * @param cipherArray
     * The Encrypted array to decrypt
     * 
     * @param maxLength
     * The maximum length, in bytes, of the input data.
     * 
     * @return 
     * The decrypted byte[]
     */
    public byte[] decryptData(byte [] cipherArray, int maxLength){
        ByteBuffer buf = ByteBuffer.wrap(cipherArray);
        int ivLen = buf.getInt();
        if(ivLen < 12 || ivLen > 16){
            throw new IllegalArgumentException("Initialization Vector is of Invalid size " + ivLen + "! Someone May Be Doing Nasty Things!");
        }
        
        if(buf.remaining() > 10000000){
            throw new IllegalArgumentException("Message Length is Longer Than The Limit of" + maxLength + "bytes. Current Length: " + buf.remaining());
        }
        
        byte[] iv = new byte[ivLen];
        
        buf.get(iv);
        
        byte[] crypted = new byte[buf.remaining()];
        
        byte[] output = {};
        
        buf.get(crypted);
        try {
            final Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            GCMParameterSpec Spec = new GCMParameterSpec(128, iv);
            cipher.init(Cipher.DECRYPT_MODE, Key, Spec);
            
            output = cipher.doFinal(crypted);
            
            
        } catch (InvalidAlgorithmParameterException | InvalidKeyException | NoSuchAlgorithmException | BadPaddingException | IllegalBlockSizeException | NoSuchPaddingException ex){
            Logger.getLogger(AESToolKit.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return output;
    }
    
    /**
     * decrypts a byte[] from another instance of AESToolKit. Only works if both
     * instances are sharing the same key. This call uses a default value for 
     * maxLength, defaulting to 10MB of data.
     * 
     * @param cipherArray
     * The Encrypted array to decrypt
     * 
     * @return 
     * The decrypted byte[]
     */
    public byte[] decryptData(byte [] cipherArray){
        return decryptData(cipherArray, 10000000);
    }
    
    /**
     * A method to retrieve the key used inside the toolkit. Be very carefull with
     * this information!
     * 
     * @return 
     * The Key
     */
    public SecretKey getKey(){
        return Key;
    }
    
    /**
     * Retrieves the bytes used to generate the key. This information is just as 
     * sensitive as the Key itself!
     * 
     * @return
     * The Byte[] used to generate the key
     */
    public byte[] getKeyBytes(){
        return keyBytes;
    }
    
    
    /**
     * Returns whether or not the key has been generated
     * 
     * @return 
     * does a key exist?
     */
    public boolean keyGenerated(){
        try {
            if(Key.equals(null)){
                return false;
            } else { 
                return true;
            }
        } catch (NullPointerException ex){
            return false;
        }
    }
}